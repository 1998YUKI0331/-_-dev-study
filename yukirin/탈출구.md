# [탈출구](https://ko.react.dev/learn/escape-hatches)
일부 컴포넌트는 React 외부의 시스템을 제어하고 동기화해야 한다. 이 장에서는 **React의 "외부"로 나가서 외부 시스템에 연결할 수 있는 탈출구**를 배운다. 대부분의 App 로직과 데이터 흐름은 이러한 기능에 의존하면 안된다.

## Ref로 값 참조하기
컴포넌트가 특정 데이터를 기억하면서, 해당 데이터가 업데이트 될 때 **렌더링을 유발하지 않도록 하려면 ref를 사용**한다.
### 컴포넌트에 ref를 추가하기
React에서 useRef Hook을 가져와 컴포넌트에 ref를 추가할 수 있으며 useRef는 아래와 같은 객체를 반환한다.
```javascript
import { useRef } from 'react';
const ref = useRef(0);
{
  current: 0 // useRef에 전달한 값
}
```
- `ref`는 읽고 수정할 수 있는 `current` 프로퍼티를 가진 일반 자바스크립트 객체이다.
- state와 ref는 리렌더링 되어도 유지되지만(지역변수는 초기화) ref는 레런더링 유발은 하지 않는다.
> [Why should we not write or read ref.current during rendering?](https://stackoverflow.com/questions/76109867/why-should-we-not-write-or-read-ref-current-during-rendering)
### refs의 좋은 예시
아래 두 원칙을 따르면 ref를 사용한 컴포넌트를 보다 쉽게 예측할 수 있다.
- refs를 escape hatch로 간주한다: Refs는 외부 작업을 할 때 유용하다.
- 렌더링 중에 `ref.current`를 읽거나 쓰지 않는다: `ref.current`는 언제 변하는지 React가 모르기 때문에 렌더링할 때 읽어도 컴포넌트 동작을 예측하기 어렵다.

## Ref로 DOM 조작하기
### ref로 노드 가져오기
DOM 노드에 접근하기 위해 JSX tag의 `ref` 어트리뷰트로 전달할 수 있다.
```javascript
const myRef = useRef(null);
<div ref={myRef}>
```
- React는 `<div>`의 DOM 노드를 생성할 때 노드에 대한 참조를 `myRef.current`에 넣는다.
- 이 DOM 노드를 이벤트 핸들러에서 접근하거나 노드에 정의된 내장 [브라우저 API](https://developer.mozilla.org/en-US/docs/Web/API)를 사용할 수 있다.
### ref 콜백으로 ref 리스트 관리하기
목록의 아이템마다 ref가 필요하고, 얼마나 많은 ref가 필요할지 예측할 수 없는 경우가 있다. 이럴 경우, **`ref` 어트리뷰트에 함수를 전달**한다. 이를 ref 콜백이라 한다.
```javascript
const itemsRef = useRef(null);
function getMap() {
  if (!itemsRef.current) {
    itemsRef.current = new Map(); // 처음 사용하는 경우, Map을 초기화
  }
  return itemsRef.current;
}

{catList.map((cat) => (
  <li
    key={cat}
    ref={(node) => {
      const map = getMap();
      node ? map.set(cat, node) : map.delete(cat)
    }}
  >
    <img src={cat} />
  </li>
))}
```
- 이 예시에서 itemsRef는 하나의 DOM 노드가 아닌, 식별자와 DOM 노드로 연결된 [Map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map)을 갖는다.
> [How can I use multiple refs for an array of elements with hooks?](https://stackoverflow.com/questions/54633690/how-can-i-use-multiple-refs-for-an-array-of-elements-with-hooks)
### 다른 컴포넌트의 DOM 노드 접근하기 
`<input />`같은 브라우저 element와 달리 `<MyInput />`과 같은 직접 만든 컴포넌트에 ref를 주입할 때는 `null`이 기본적으로 주어진다.
```javascript
const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus(); // 오직 focus만 노출
    },
  }));
  return <input {...props} ref={realInputRef} />;
});
```
- React는 기본적으로 다른 컴포넌트의 DOM 노드에 접근하는 것을 허용하지 않는다.
- 따라서 특정 컴포넌트에서 소유한 DOM 노드를 선택적으로 노출하기 위해 위 예시와 같이 할 수 있다.
> [React18의 새로운 기능 flushsync](https://kyounghwan01.github.io/blog/React/React18/flushsync/#react18-state-%E1%84%87%E1%85%A2%E1%84%8E%E1%85%B5%E1%86%BC)
