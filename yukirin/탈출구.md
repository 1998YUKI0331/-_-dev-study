# [탈출구](https://ko.react.dev/learn/escape-hatches)
일부 컴포넌트는 React 외부의 시스템을 제어하고 동기화해야 한다. 이 장에서는 **React의 "외부"로 나가서 외부 시스템에 연결할 수 있는 탈출구**를 배운다. 대부분의 App 로직과 데이터 흐름은 이러한 기능에 의존하면 안된다.

## Ref로 값 참조하기
컴포넌트가 특정 데이터를 기억하면서, 해당 데이터가 업데이트 될 때 **렌더링을 유발하지 않도록 하려면 ref를 사용**한다.
### 컴포넌트에 ref를 추가하기
React에서 useRef Hook을 가져와 컴포넌트에 ref를 추가할 수 있으며 useRef는 아래와 같은 객체를 반환한다.
```javascript
import { useRef } from 'react';
const ref = useRef(0);
{
  current: 0 // useRef에 전달한 값
}
```
- `ref`는 읽고 수정할 수 있는 `current` 프로퍼티를 가진 일반 자바스크립트 객체이다.
- state와 ref는 리렌더링 되어도 유지되지만(지역변수는 초기화) ref는 레런더링 유발은 하지 않는다.
> [Why should we not write or read ref.current during rendering?](https://stackoverflow.com/questions/76109867/why-should-we-not-write-or-read-ref-current-during-rendering)
### refs의 좋은 예시
아래 두 원칙을 따르면 ref를 사용한 컴포넌트를 보다 쉽게 예측할 수 있다.
- refs를 escape hatch로 간주한다: Refs는 외부 작업을 할 때 유용하다.
- 렌더링 중에 `ref.current`를 읽거나 쓰지 않는다: `ref.current`는 언제 변하는지 React가 모르기 때문에 렌더링할 때 읽어도 컴포넌트 동작을 예측하기 어렵다.

## Ref로 DOM 조작하기
### ref로 노드 가져오기
DOM 노드에 접근하기 위해 JSX tag의 `ref` 어트리뷰트로 전달할 수 있다.
```javascript
const myRef = useRef(null);
<div ref={myRef}>
```
- React는 `<div>`의 DOM 노드를 생성할 때 노드에 대한 참조를 `myRef.current`에 넣는다.
- 이 DOM 노드를 이벤트 핸들러에서 접근하거나 노드에 정의된 내장 [브라우저 API](https://developer.mozilla.org/en-US/docs/Web/API)를 사용할 수 있다.
### ref 콜백으로 ref 리스트 관리하기
목록의 아이템마다 ref가 필요하고, 얼마나 많은 ref가 필요할지 예측할 수 없는 경우가 있다. 이럴 경우, **`ref` 어트리뷰트에 함수를 전달**한다. 이를 ref 콜백이라 한다.
```javascript
const itemsRef = useRef(null);
function getMap() {
  if (!itemsRef.current) {
    itemsRef.current = new Map(); // 처음 사용하는 경우, Map을 초기화
  }
  return itemsRef.current;
}

{catList.map((cat) => (
  <li
    key={cat}
    ref={(node) => {
      const map = getMap();
      node ? map.set(cat, node) : map.delete(cat)
    }}
  >
    <img src={cat} />
  </li>
))}
```
- 이 예시에서 itemsRef는 하나의 DOM 노드가 아닌, 식별자와 DOM 노드로 연결된 [Map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map)을 갖는다.
> [How can I use multiple refs for an array of elements with hooks?](https://stackoverflow.com/questions/54633690/how-can-i-use-multiple-refs-for-an-array-of-elements-with-hooks)
### 다른 컴포넌트의 DOM 노드 접근하기 
`<input />`같은 브라우저 element와 달리 `<MyInput />`과 같은 직접 만든 컴포넌트에 ref를 주입할 때는 `null`이 기본적으로 주어진다.
```javascript
const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus(); // 오직 focus만 노출
    },
  }));
  return <input {...props} ref={realInputRef} />;
});
```
- React는 기본적으로 다른 컴포넌트의 DOM 노드에 접근하는 것을 허용하지 않는다.
- 따라서 특정 컴포넌트에서 소유한 DOM 노드를 선택적으로 노출하기 위해 위 예시와 같이 할 수 있다.
> [React18의 새로운 기능 flushsync](https://kyounghwan01.github.io/blog/React/React18/flushsync/#react18-state-%E1%84%87%E1%85%A2%E1%84%8E%E1%85%B5%E1%86%BC)

## Effect로 동기화하기
### Effect란 무엇이고 이벤트와는 어떻게 다른가요? 
Effect에 대해 자세히 알아보기 전에, 컴포넌트 내부의 2가지 로직 유형에 대해 알아야 한다.
- 렌더링 코드: 순수한 로직으로, props와 state를 적절히 변형해서 JSX를 반환한다.
- 이벤트 핸들러: 무언가를 하는 컴포넌트 내부의 중첩 함수이다. 사용자 작업으로 인해 발생하는 [부수 효과](https://en.wikipedia.org/wiki/Side_effect_(computer_science))를 포함한다.

가끔은 위 2가지로 충분하지 않다. **Effect는 렌더링에 의해 발생하는 부수 효과를 특정하는 것**으로, 특정 이벤트가 아닌 렌더링에 의해 직접 발생한다.
### Effect의 의존성 지정하기
기존적으로 Effect는 모든 렌더링 후에 실행된다. 따라서 불필요한 재실행을 방지하려면 의존성 배열을 추가해야 한다.
```javascript
useEffect(() => {
  // ...
}, [dependencies]);
```
- React는 [Object.is()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 비교를 사용하여 종속성 값을 비교한다.
> [JavaScript "loose" comparison step by step](https://felix-kling.de/js-loose-comparison/)

추가적으로, `ref`는 의존성 배열에서 생략해도 된다. 왜냐하면 `ref` 객체는 **안정된 식별성**을 갖기 때문이다.
- React는 동일한 useRef 호출에서 항상 [같은 객체를 얻을 수 있음](https://ko.react.dev/reference/react/useRef#returns)을 보장한다.
### 필요하다면 클린업 추가하기
예를 들어 ChatRoom 컴포넌트의 경우, 서용자가 다른 화면으로 이동한 경우, 즉 ChatRoom 컴포넌트가 언마운트 된 경우 연결을 끊어줘야 한다.
```javascript
useEffect(() => {
  const connection = createConnection();
  connection.connect(); // 컴포넌트가 마운트 될 때 connect
  return () => {
    connection.disconnect(); // 컴포넌트가 언마운트 될 때 disconnect
  };
}, []);
```
- Effect로 이벤트를 구독한다면, 클린업 함수에서 구독을 해지
- Effect가 어떤 element를 애니메이션으로 표시하는 경우, 클린업 함수에서 애니메이션을 초기 값으로 재설정
### 각각의 렌더링은 고유한 Effect를 갖는다.
React는 항상 이전 렌더의 Effect를 다음 렌더의 Effect보다 먼저 정리한다. 그리고 각 Effect는 해당 렌더의 state를 캡처한다.

## Effect가 필요하지 않을 수도 있습니다
컴포넌트가 사용자에게 표시되었기 때문에 실행되어야 하는 코드에만 Effect를 사용해야 한다.
### 불필요한 Effect를 제거하는 방법
- 렌더링을 위해 데이터를 변환하는 데 Effect가 필요하지 않다.
- 사용자 이베트를 처리하는 데 Effect가 필요하지 않다.
> [React 학습 | 불필요한 state 피하기](https://ko.react.dev/learn/choosing-the-state-structure#avoid-redundant-state)

### 비용이 많이 드는 계산 캐싱하기
```javascript
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // todos나 filter가 변경되지 않는 한 getFilteredTodos()를 다시 실행하지 않음
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}
```
`getFilteredTodos` 혹은 `todos`가 비용이 많이 드는 계산이라면 `useMemo`로 캐싱(또는 [메모제이션](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98))할 수 있다.
